import React from 'react'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest'
import { ImageUpload } from '../ImageUpload'
import { uploadImage } from '@/shared/config/cloudinary'

// Mock Cloudinary upload function
vi.mock('@/shared/config/cloudinary', () => ({
  uploadImage: vi.fn()
}))

// Mock environment variables
const mockEnv = {
  VITE_CLOUDINARY_CLOUD_NAME: 'test-cloud',
  VITE_CLOUDINARY_UPLOAD_PRESET: 'test-preset'
}

vi.stubGlobal('import', {
  meta: {
    env: mockEnv
  }
})

describe('ImageUpload', () => {
  const mockOnImageUpload = vi.fn()
  const mockOnImageRemove = vi.fn()
  const mockUploadImage = vi.mocked(uploadImage)

  beforeEach(() => {
    vi.clearAllMocks()
    // Mock FileReader
    global.FileReader = vi.fn().mockImplementation(() => ({
      EMPTY: 0,
      LOADING: 1,
      DONE: 2,
      readAsDataURL: vi.fn(),
      onload: null,
      result: 'data:image/jpeg;base64,test-image-data'
    })) as any
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('renders upload area with correct text', () => {
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    expect(screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞')).toBeInTheDocument()
    expect(screen.getByText('–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: JPG, PNG, WebP (–¥–æ 10MB)')).toBeInTheDocument()
    expect(screen.getByText('üì∑')).toBeInTheDocument()
  })

  it('shows current image when currentImageUrl is provided', () => {
    const imageUrl = 'https://example.com/image.jpg'
    render(
      <ImageUpload 
        onImageUpload={mockOnImageUpload} 
        currentImageUrl={imageUrl}
      />
    )
    
    const image = screen.getByAltText('–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä')
    expect(image).toBeInTheDocument()
    expect(image).toHaveAttribute('src', imageUrl)
    expect(screen.getByText('–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –∑–∞–º–µ–Ω—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è')).toBeInTheDocument()
  })

  it('handles file selection via input', async () => {
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    mockUploadImage.mockResolvedValue('https://example.com/uploaded.jpg')
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(mockUploadImage).toHaveBeenCalledWith(file, 3, expect.any(Function))
    })
  })

  it('handles drag and drop', async () => {
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    mockUploadImage.mockResolvedValue('https://example.com/uploaded.jpg')
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    
    fireEvent.dragOver(uploadArea!, { dataTransfer: { files: [file] } })
    fireEvent.drop(uploadArea!, { dataTransfer: { files: [file] } })
    
    await waitFor(() => {
      expect(mockUploadImage).toHaveBeenCalledWith(file, 3, expect.any(Function))
    })
  })

  it('shows error for invalid file type', async () => {
    const file = new File(['test'], 'test.txt', { type: 'text/plain' })
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(screen.getByText('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ')).toBeInTheDocument()
    })
  })

  it('shows error for file too large', async () => {
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    Object.defineProperty(file, 'size', { value: 11 * 1024 * 1024 }) // 11MB
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(screen.getByText('–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 10MB')).toBeInTheDocument()
    })
  })

  it('shows error for unsupported format', async () => {
    const file = new File(['test'], 'test.gif', { type: 'image/gif' })
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(screen.getByText('–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ JPG, PNG –∏ WebP —Ñ–æ—Ä–º–∞—Ç—ã')).toBeInTheDocument()
    })
  })

  it('shows progress during upload', async () => {
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    mockUploadImage.mockImplementation(() => 
      new Promise(resolve => setTimeout(() => resolve('https://example.com/uploaded.jpg'), 1000))
    )
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(screen.getByText('–ó–∞–≥—Ä—É–∑–∫–∞...')).toBeInTheDocument()
    })
  })

  it('shows success message after upload', async () => {
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    mockUploadImage.mockResolvedValue('https://example.com/uploaded.jpg')
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(screen.getByText('–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ!')).toBeInTheDocument()
    })
    
    expect(mockOnImageUpload).toHaveBeenCalledWith('https://example.com/uploaded.jpg')
  })

  it('shows error when upload fails', async () => {
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    mockUploadImage.mockRejectedValue(new Error('Upload failed'))
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(screen.getByText('Upload failed')).toBeInTheDocument()
    })
  })

  it('handles remove image when onImageRemove is provided', () => {
    const imageUrl = 'https://example.com/image.jpg'
    render(
      <ImageUpload 
        onImageUpload={mockOnImageUpload} 
        onImageRemove={mockOnImageRemove}
        currentImageUrl={imageUrl}
      />
    )
    
    const removeButton = screen.getByText('–£–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ')
    fireEvent.click(removeButton)
    
    expect(mockOnImageRemove).toHaveBeenCalled()
  })

  it('does not show remove button when onImageRemove is not provided', () => {
    const imageUrl = 'https://example.com/image.jpg'
    render(
      <ImageUpload 
        onImageUpload={mockOnImageUpload} 
        currentImageUrl={imageUrl}
      />
    )
    
    expect(screen.queryByText('–£–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ')).not.toBeInTheDocument()
  })

  it('is disabled when disabled prop is true', () => {
    render(<ImageUpload onImageUpload={mockOnImageUpload} disabled />)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    expect(fileInput).toBeDisabled()
  })

  it('shows configuration error when Cloudinary is not configured', async () => {
    // Mock empty environment
    vi.stubGlobal('import', {
      meta: {
        env: {}
      }
    })
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    // The error should be shown immediately on mount
    await waitFor(() => {
      expect(screen.getByText(/–û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ Cloudinary/)).toBeInTheDocument()
    })
  })

  it('handles drag over and drag leave events', () => {
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    
    fireEvent.dragOver(uploadArea!)
    fireEvent.dragLeave(uploadArea!)
    
    // Component should handle these events without errors
    expect(uploadArea).toBeInTheDocument()
  })

  it('calls onImageUpload with correct URL after successful upload', async () => {
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    const uploadedUrl = 'https://example.com/uploaded.jpg'
    mockUploadImage.mockResolvedValue(uploadedUrl)
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(mockOnImageUpload).toHaveBeenCalledWith(uploadedUrl)
    })
  })

  it('shows upload attempt counter during retries', async () => {
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })
    mockUploadImage.mockImplementation((file, maxAttempts, onAttempt) => {
      onAttempt?.(2)
      return Promise.resolve('https://example.com/uploaded.jpg')
    })
    
    render(<ImageUpload onImageUpload={mockOnImageUpload} />)
    
    const uploadArea = screen.getByText('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞').closest('div')
    fireEvent.click(uploadArea!)
    
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
    fireEvent.change(fileInput, { target: { files: [file] } })
    
    await waitFor(() => {
      expect(screen.getByText('–ü–æ–ø—ã—Ç–∫–∞ 2/3')).toBeInTheDocument()
    })
  })
})
